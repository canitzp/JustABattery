plugins {
    id "java-library"
    id "idea"
    id 'net.neoforged.moddev' version '2.0.107'
    id "com.modrinth.minotaur" version "2.+"
    id 'net.darkhax.curseforgegradle' version '1.+'
}

version = "${project.mod_version}"
group = "${project.mod_namespace}"
base {
    archivesName = "${project.mod_name}"
}

java.toolchain.languageVersion = JavaLanguageVersion.of(21)

println('Java: ' + System.getProperty('java.version') + ' JVM: ' + System.getProperty('java.vm.version') + '(' + System.getProperty('java.vendor') + ') Arch: ' + System.getProperty('os.arch'))

neoForge {
    version = project.forge_version

    parchment {
        mappingsVersion = project.parchment_mapping_version
        minecraftVersion = project.parchment_mc_version
    }

    runs {
        configureEach {
            //systemProperty 'forge.logging.markers', 'REGISTRIES'
            logLevel = org.slf4j.event.Level.DEBUG
        }
        client {
            client()
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
            gameDirectory = project.file('runs/client')
        }
        server {
            server()
            programArgument '--nogui'
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
            gameDirectory = project.file('runs/server')
        }
        gameTestServer {
            type = "gameTestServer"
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
            gameDirectory = project.file('runs/gametest')
        }
        data {
            clientData()
            programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').getAbsolutePath(), '--existing', file('src/main/resources/').getAbsolutePath()
            gameDirectory = project.file('runs/data')
        }
    }
    mods {
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
    }
}
// Include resources generated by data generators.
sourceSets.main.resources { srcDir 'src/generated/resources' }

configurations {
    runtimeClasspath.extendsFrom localRuntime
}

repositories {
    mavenLocal()
    maven {
        url = "https://maven.blamejared.com/"
    }
}

dependencies {
    //implementation fg.deobf("mezz.jei:jei-${project.jei_version}")
}

// This block of code expands all declared replace properties in the specified resource targets.
// A missing property will result in an error. Properties are expanded using ${} Groovy notation.
var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [
            mod_loader: "javafml",
            loader_version: "${project.valid_forge_versions}",
            license: "${project.license}",
            mod_id: "${project.mod_id}",
            mod_version: "${project.mod_version}",
            mc_version_range: "${project.mc_version_range}"
    ]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}
// Include the output of "generateModMetadata" as an input directory for the build
// this works with both building through Gradle and the IDE.
sourceSets.main.resources.srcDir generateModMetadata
// To avoid having to run "generateModMetadata" manually, make it run on every project reload
neoForge.ideSyncTask generateModMetadata

jar {
    manifest {
        attributes([
                "Specification-Title": project.mod_name,
                "Specification-Vendor": "canitzp",
                "Specification-Version": "1",
                "Implementation-Title": project.name,
                "Implementation-Version": "${version}",
                "Implementation-Vendor" :"canitzp",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

idea {
    module {
        inheritOutputDirs = true
        downloadSources = true
        downloadJavadoc = true
    }
}

modrinth {
    token = System.getenv("MODRINTH_TOKEN")
    projectId = "hzegx5nn"
    versionNumber = "${project.mod_version}"
    versionName = "${project.mod_name} - ${project.mod_version} (for ${project.release_minecraft_versions})"
    versionType = "release"
    uploadFile = jar
    gameVersions = project.release_minecraft_versions.split("/").collect()
    loaders = project.release_mod_loaders.toLowerCase().split("/").collect()
    changelog = String.join("\n", rootProject.file("CHANGELOG.md").text.lines().takeWhile(s -> !s.isEmpty()).toList())
    syncBodyFrom = rootProject.file("README.md").text
}

tasks.modrinth.dependsOn(tasks.modrinthSyncBody)

//noinspection UnnecessaryQualifiedReference
task publishCurseForge(type: net.darkhax.curseforgegradle.TaskPublishCurseForge) {
    group = "publishing"
    apiToken = System.getenv('CURSEFORGE_TOKEN')

    def mainFile = upload(509638, jar)
    mainFile.displayName = "${project.mod_name} - ${project.mod_version} (for ${project.release_minecraft_versions})"
    mainFile.releaseType = "release"
    mainFile.changelogType = 'markdown'
    mainFile.changelog = file("CHANGELOG.md")
    for (final def modloader in "${project.release_mod_loaders}".split("/")) {
        mainFile.addModLoader("${modloader}")
    }
    for (final def java_version in "${project.release_java_versions}".split("/")) {
        mainFile.addJavaVersion("${java_version}")
    }
    for (final def minecraft_version in "${project.release_minecraft_versions}".split("/")) {
        mainFile.addGameVersion("${minecraft_version}")
    }
}